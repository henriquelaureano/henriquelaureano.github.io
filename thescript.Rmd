---
title: "Predicting soccer match scores"
author: "[Henrique Ap. Laureano](http://www.leg.ufpr.br/~henrique)"
date: "*Last modification on* `r Sys.time()`"
include-before:
  - '\(\newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}\)'
output:
  html_document:
    toc: true
    toc_float: true
    css: font_size.css
    code_folding: show
---

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri("logo_leg.jpg"),
               alt = 'logo',
               style = 'position:absolute; top:0; right:0;
                        padding:10px; width:200px;')
options(width = 100)
library(knitr)
opts_chunk$set(fig.path = "iBagens/",
               cache = TRUE,
               cache.path = "cache/",
               warning = FALSE,
               comment = NA,
               prompt = FALSE)
```

***

# How?

INLA.

# Show me!

## Data

Premier League results for 2018-19 season

texttt{https://www.soccer24.com/england/premier-league-2018-2019/results/}

```{r}
pacman::p_load("pacman", "tidyverse", "DT", "INLA", "viridis", "patchwork",
               "kableExtra", "scales")

dat = read.table("~/Desktop/henrique/PremierLeague-2018-19.txt",
                 col.names = c("round", "home", "away", "x", "y"))

teams = as.character(sort(unique(dat$home)))
n_teams = length(teams) ; n_matches = nrow(dat) ; n_rounds = max(dat$round)

n_table <- matrix(c(n_teams, n_matches, n_rounds))
dimnames(n_table) <- list(c("Teams", "Matches", "Round"), "Number")
n_table
```

The first row

```{r}
dat[1, ]
```

need to become something like:

TeamA | TeamB | round | home-adv | num goals scored by A vs B in match k

```{r}
dat_model <- data.frame()
for(i in 1:n_matches){
    dat_model = rbind(
        dat_model,
        c(dat$home[i], dat$away[i], dat$round[i],  1, dat$x[i]),
        c(dat$away[i], dat$home[i], dat$round[i], -1, dat$y[i]))
}
names(dat_model) = c("TeamA", "TeamB", "round", "home.adv", "score")
dat_model <-
    dat_model %>%
    as_tibble() %>%
    mutate(round_home = round, round_away = round, round = NULL)

datatable(dat_model, options = list(pageLength = 6),
          class = 'cell-border stripe', rownames = FALSE)
```

## Models

\[
 \begin{align}
  x_{i} &\sim \text{Poisson}
  \left(\lambda_{x_{i}} =
        \exp\{\mu_{H} + s_{A_{i}}^{t} - s_{B_{i}}^{t}\}
  \right)\\
  \log \lambda_{x_{i}} &= \mu_{H} + s_{A_{i}}^{t} - s_{B_{i}}^{t},
  \quad i = 1, 3, 5, \dots, \quad t = 1, \dots, 38,\\
   y_{i} &\sim \text{Poisson}
  \left(\lambda_{y_{i}} =
        \exp\{-\mu_{H} + s_{B_{i}}^{t} - s_{A_{i}}^{t}\}
  \right)\\
  \log \lambda_{y_{i}} &= -\mu_{H} + s_{B_{i}}^{t} - s_{A_{i}}^{t},
  \quad i = 2, 4, 6, \dots, \quad t = 1, \dots, 38,
 \end{align}
\]

where the index $t$ again defines the values info related to the
variable 'round' in the dataset. For the implementation, we can more or
less follow what was done earlier, but keeping in mind that each
strength team now depends on the time each match was played during the
season. Hence the 'copy 'structure is now being applied on the variable
'round' and 'round2'(of course a copy of the variable round for TeamB
\dots) as follow

```{r}
w_roundA = rep( 1, times = nrow(dat_model))
w_roundB = rep(-1, times = nrow(dat_model))

homeperformance <- function(teams, ploteam, n_rounds, model) {
    n_teams <- length(ploteam)
    dat_plot <- matrix(NA, nrow = n_rounds, ncol = n_teams + 1)
    dat_plot[ ,  1] <- 1:n_rounds
    dat_plot[ , -1] <- sapply(
        ploteam,
        function(i) model$
                    summary.random$
                    round_home$
                    mean[inla.idx(1:n_rounds,
                                  replicate = which(teams == i),
                                  nrep = length(teams)
                                  )])
    dat_plot <- data.frame(dat_plot)
    names(dat_plot) <- c("round", ploteam)
    dat_plot <- dat_plot %>%
        gather(key = "team", value = "value", -round)
    ggplot(dat_plot, aes(x = round, y = value)) +
        geom_line(aes(color = team), size = 1) +
        ylim(c(.17, .735)) +
        labs(x = "rounds", y = "Posterior mean") +
        scale_color_viridis(discrete = TRUE, breaks = ploteam, name = NULL) +
        theme_minimal()
}
```

### RW1 model

```{r}
formula_rw1 <- score ~ -1 + home.adv +
    f(round_home, w_roundA, model = "rw1",
      hyper = list(prec = list(prior = "pc.prec", param = c(1, .01))),
      scale.model = TRUE, replicate = TeamA, constr = FALSE) +
    f(round_away, w_roundB, copy = "round_home", replicate = TeamB)

model_rw1 = inla(formula_rw1, data = dat_model,
                 control.predictor = list(link = 1),
                 control.compute = list(config = TRUE, cpo = TRUE,
                                        dic = TRUE, waic = TRUE),
                 family = "poisson")
top5 = c("ManchesterCity", "Liverpool", "Chelsea", "Tottenham", "Arsenal")
```

### AR1 model

```{r}
formula_ar1 <- score ~ -1 + home.adv +
    f(round_home, w_roundA, model = "ar1",
      hyper = list(theta1 = list(prior = "pc.prec", param = c(1, .01)),
                   theta2 = list(prior = "pc.cor1", param = c(.1, .9))),
    replicate = TeamA, constr = FALSE) +
    f(round_away, w_roundB, copy = "round_home", replicate = TeamB)

model_ar1 = inla(formula_ar1, data = dat_model,
                 control.predictor = list(link = 1),
                 control.compute = list(config = TRUE, cpo = TRUE,
                                        dic = TRUE, waic = TRUE),
                 family = "poisson")
```

### Matern model

We can exploit a one dimensional Matern model where we construct a mesh
on the time points given by the round variable and then apply a joint PC
prior on the practical range and marginal standard deviation parameters
of the SPDE model.

```{r}
formula_matern <- score ~ -1 + home.adv +
    f(round_home, w_roundA,
      model = inla.spde2.pcmatern(mesh = inla.mesh.1d(1:n_rounds),
                                  alpha = 2,
                                  prior.range = c(2, .05),
                                  prior.sigma = c(1, .01)),
      replicate = TeamA, constr = FALSE) +
    f(round_away, w_roundB, copy = "round_home", replicate = TeamB)

model_matern = inla(formula_matern, data = dat_model,
                    control.predictor = list(link = 1),
                    control.compute = list(config = TRUE, cpo = TRUE,
                                           dic = TRUE, waic = TRUE),
                    family = "poisson")
```

```{r, fig.width=10}
plot_rw1 <- homeperformance(teams, ploteam = top5, n_rounds,
                            model = model_rw1)

plot_ar1 <- homeperformance(teams, ploteam = top5, n_rounds,
                            model = model_ar1)

plot_matern <- homeperformance(teams, ploteam = top5, n_rounds,
                               model = model_matern)

plot_all <- plot_rw1 | plot_ar1 | plot_matern

plot_all +
    plot_layout(guides = "collect") +
    plot_annotation(title = "Premier League Top5 Performance",
                    tag_levels = "A")
```

```{r}
teams_mean <- sapply(
    teams,
    function(i) mean(model_rw1$
                     summary.random$
                     round_home$
                     mean[inla.idx(1:n_rounds,
                                   replicate = which(teams == i),
                                   nrep = length(teams)
                                   )]))
performance <- data.frame(cbind(teams, teams_mean))
names(performance) <- c("Team", "Performance")

performance$Performance <- as.numeric(as.character(performance$Performance))

index_order <- order(performance$Performance, decreasing = TRUE)
performance <- performance[index_order, ]
rownames(performance) <- NULL

team_points <- numeric(n_teams)
names(team_points) <- teams

for (i in 1:nrow(dat)) {
  home = dat[i, "home"]; x = dat[i, "x"]
  away = dat[i, "away"]; y = dat[i, "y"]
  team_points[c(home, away)] <- team_points[c(home,away)] +
      if (x > y) c(3, 0) else
      if (y > x) c(0, 3) else c(1, 1)
}
table_points <- cbind(sort(team_points, decreasing = TRUE))
index_true <- order(team_points, decreasing = TRUE)

compare <- cbind(as.character(performance$Team),
                 names(team_points)[index_true],
                 team_points[index_true])
colnames(compare) <- c("Rank by performance", "Real rank", "Points")
rownames(compare) <- 1:20
print(compare, quote = FALSE)

plot_home.adv <- function(model) {
    df = data.frame(model$marginals.fixed$home.adv)
    ggplot(df, aes(x = x)) +
        geom_density(adjust = 3, size = 1) +
        scale_x_continuous(name = "Home Advantage") +
        scale_y_continuous(name = "Density") +
        theme_minimal()
}
home.adv_all <-
    plot_home.adv(model_rw1) |
    plot_home.adv(model_ar1) |
    plot_home.adv(model_matern)
home.adv_all +
    plot_annotation(title = "Marginal distribution of Home Advantages",
                    tag_levels = "A")

plotmed <- function(model, teams, index_order, n_rounds, type) {
    teams <- factor(teams)
    orderedteams <- factor(teams, levels(teams)[index_order])
    teams_0.025 <- sapply(
        teams,
        function(i) mean(model$
                         summary.random$
                         round_home$
                         `0.025quant`[inla.idx(1:n_rounds,
                                               replicate = which(teams == i),
                                               nrep = length(teams)
                                               )]))
    teams_0.5 <- sapply(
        teams,
        function(i) mean(model$
                         summary.random$
                         round_home$
                         `0.5quant`[inla.idx(1:n_rounds,
                                             replicate = which(teams == i),
                                             nrep = length(teams)
                                             )]))
    teams_0.975 <- sapply(
        teams,
        function(i) mean(model$
                         summary.random$
                         round_home$
                         `0.975quant`[inla.idx(1:n_rounds,
                                               replicate = which(teams == i),
                                               nrep = length(teams)
                                               )]))
    if (type == 1) {
        plot(orderedteams[index_order], teams_0.5[index_order],
             las = 2, xlab = NULL, ylab = "Performance",
             ylim = c(-.8, 1), main = "Team performance")
        points(orderedteams[index_order],
               teams_0.025[index_order], pch = 2, cex = .75)
        points(orderedteams[index_order],
               teams_0.975[index_order], pch = 6, cex = .75)
    } else {
        df <- data.frame(variable = teams[index_order],
                         color = seq(n_teams),
                         median = teams_0.5[index_order],
                         start = teams_0.025[index_order],
                         end = teams_0.975[index_order])
        ggplot(df, aes(ymin = start, ymax = end, x = variable)) +
            geom_linerange(aes(color = color),
                           position = position_dodge(width = .2),
                           size = 3,
                           show.legend = FALSE) +
            coord_flip() +
            geom_point(mapping = aes(x = variable, y = median)) +
            labs(x = NULL, y = "Posterior") +
            scale_color_viridis() +
            theme_minimal()
    }
}

par(mar = c(7, 4, 2, 1) + .1, mfrow = c(1, 3))
plotmed(model_rw1, teams, index_order, n_rounds, type = 1)
plotmed(model_ar1, teams, index_order, n_rounds, type = 1)
plotmed(model_matern, teams, index_order, n_rounds, type = 1)

pm_rw1 <- plotmed(model_rw1, teams, index_order, n_rounds, type = 2)
pm_ar1 <- plotmed(model_ar1, teams, index_order, n_rounds, type = 2)
pm_matern <- plotmed(model_matern, teams, index_order, n_rounds, type = 2)

pm_all <- pm_rw1 | pm_ar1 | pm_matern

pm_all +
    plot_annotation(title = "Premier League Home performances",
                    tag_levels = "A")
```

```{r}
## x1 = factor(teams)

## x2 = c(1:n.teams)
## x3 = M2.res$summary.random$AttackA$mean
## x4 = M2.res$summary.random$AttackA$`0.025quant`
## x5 = M2.res$summary.random$AttackA$`0.975quant`
## mydata2 = data.frame(variable = x1,
##                      color = x2, mean = x3, start = x4, end = x5)

## ggplot(mydata2, aes(ymin = start, ymax = end,  x = variable)) +
##     geom_linerange(aes(color = color),
##                    position = position_dodge(width = 0.2), size = 3) +
##     coord_flip() +
##     geom_point(mapping = aes(x = variable, y = mean)) +
##     labs(title="Team Attacks")
## dat1.temp = t(apply(cbind(dat1$TeamA,dat1$TeamB), 1, sort)) #temporal
## dat3  = dat1 %>% as_tibble() %>% mutate(
##   TeamAB = interaction(dat1.temp[,1], dat1.temp[,2], drop = TRUE, sep = ":")
## )
## head(dat3, n = 10)
## M3.formula = score ~ -1 + home.adv +
##     f(TeamA, rep(1, n.matches*2), model = "iid") +
##     f(TeamB, rep(-1, n.matches*2), copy = "TeamA") +
##     f(TeamAB, model = "iid")
```

```{r, eval=FALSE}
## To have a fast simulation, we'd better have these two functions
## combined because we want to simulate multiple seasons at once.
table.producer=function(res,N){
  simres=matrix(0,nrow=20,ncol=20)
  row.names(simres)=teams
  colnames(simres)=1:20
  SAMPLE = inla.posterior.sample(n = N,res)
  for (i in 1:N){
    sample = SAMPLE[[i]]$latent[1:(n_matches*2)]
    lambda=exp(sample)
    goals=rpois(length(lambda),lambda=lambda)
    new_season = data.frame("home"=dat$home,
                            "away"=dat$away,
                            "x"=goals[2*seq(1,n_matches)-1],
                            "y"=goals[2*seq(1,n_matches)])
    homescore=(new_season$x>new_season$y)*3+(new_season$x==new_season$y)
    awayscore=(new_season$x<new_season$y)*3+(new_season$x==new_season$y)
    homeres = aggregate(homescore, by=list(new_season$home),FUN=sum)
    awayscore=aggregate(awayscore, by=list(new_season$away),FUN=sum)
    num.points=homeres$x+awayscore$x
    rankorder=rank(-num.points,ties.method = "random")
    for (j in 1:20){
      simres[j,rankorder[j]]=simres[j,rankorder[j]]+1
      }
  }
  return(simres)
}
table.plot=function(simres,colindex){
simres %>%
  mutate(
   "Team"= row.names(.),
   "1" = cell_spec(simres[,1], "html",
                   color = ifelse(colindex[,1], "red", "blue")),
   "2" = cell_spec(simres[,2], "html",
                   color = ifelse(colindex[,2], "red", "blue")),
   "3" = cell_spec(simres[,3], "html",
                   color = ifelse(colindex[,3], "red", "blue")),
   "4" = cell_spec(simres[,4], "html",
                   color = ifelse(colindex[,4], "red", "blue")),
   "5" = cell_spec(simres[,5], "html",
                   color = ifelse(colindex[,5], "red", "blue")),
   "6" = cell_spec(simres[,6], "html",
                   color = ifelse(colindex[,6], "red", "blue")),
   "7" = cell_spec(simres[,7], "html",
                   color = ifelse(colindex[,7], "red", "blue")),
   "8" = cell_spec(simres[,8], "html",
                   color = ifelse(colindex[,8], "red", "blue")),
   "9" = cell_spec(simres[,9], "html",
                   color = ifelse(colindex[,9], "red", "blue")),
   "10" = cell_spec(simres[,10], "html",
                    color = ifelse(colindex[,10], "red", "blue")),
   "11" = cell_spec(simres[,11], "html",
                    color = ifelse(colindex[,11], "red", "blue")),
   "12" = cell_spec(simres[,12], "html",
                    color = ifelse(colindex[,12], "red", "blue")),
   "13" = cell_spec(simres[,13], "html",
                    color = ifelse(colindex[,13], "red", "blue")),
   "14" = cell_spec(simres[,14], "html",
                    color = ifelse(colindex[,14], "red", "blue")),
   "15" = cell_spec(simres[,15], "html",
                    color = ifelse(colindex[,15], "red", "blue")),
   "16" = cell_spec(simres[,16], "html",
                    color = ifelse(colindex[,16], "red", "blue")),
   "17" = cell_spec(simres[,17], "html",
                    color = ifelse(colindex[,17], "red", "blue")),
   "18" = cell_spec(simres[,18], "html",
                    color = ifelse(colindex[,18], "red", "blue")),
   "19" = cell_spec(simres[,19], "html",
                    color = ifelse(colindex[,19], "red", "blue")),
   "20" = cell_spec(simres[,20], "html",
                    color = ifelse(colindex[,20], "red", "blue"))
  ) %>% select("Team",
               "1","2","3","4","5","6","7","8","9","10",
               "11","12","13","14","15","16","17","18","19","20") %>%
  kable(format = "html", escape = F) %>%
  kable_styling("striped", full_width = F)
}
N=10000
```

```{R message=FALSE, warning=FALSE}
## M1.simres=table.producer(M1.res,N)

## M1.simres=M1.simres/N

## M1.simres=M1.simres[orderindex_real,]

## colindex=M1.simres>=0.05

## M1.simres[]=percent(M1.simres)

## M1.simres=as.data.frame(M1.simres)

## table.plot(M1.simres,colindex)
```

These graphs can answer one curious question. Is ManchesterCity truly
better than Liverpool in the 2018-2019 season, given the difference of
points is just 1? This question is interesting because the Manchester
City retained the league title on the final day of the season, finishing
on 98 points. At the same time, Liverpool finished runners-up with 97
points – the highest total in English top-flight history for a
second-place team.

The answer to this question is yes, according to our model. We can see
that the ManchesterCity won much more first place than Liverpool in our
simulated seasons.

We also notice that Tottenham Hotspur may be a better team compared to
Chelsea based on our model, even though it lost by one point to Chelsea.

For completeness, it seems reasonable to show how we can compute
bayesian criteria for comparing models since we have fitted quite a few
of them until now. INLA provides an easy way to do so by simply adding
the requested criteria in a control option. In the following, we fit
again all the models we have come up with. Comparison amongst the models
obtained are then performed using the most used Bayesian criteria:

1. CPO (Conditional Predictive Ordinate)
2. PIT (Predictive Integral Transform)
3. DIC (Deviance Information Criteria)
4. WAIC (Watanabe Information Criteria)

The first two quantities well summarise the goodness of fit of the model
concerning the data, while the last two represent a natural counterpart
of classical comparison criteria such as AIC and BIC.

```{r, eval=FALSE}
criteria.eval <- function(mod) {
  stopifnot(class(mod) == 'inla')
  return(c(-sum(log(mod$cpo$cpo)), mod$dic$dic, mod$waic$waic))
}
mods.obj = list(M4a.res, M4b.res, M4c.res)

inla.table = sapply(mods.obj, criteria.eval)
row.names(inla.table) = c("CPO", "DIC", "WAIC")
colnames(inla.table) = c("RW1", "AR1", "Matern")
inla.table
```

We could even assess the models through the PIT values but this does not work well for discrete data like the one from a Poisson model since they do not provide true results. This can be observed in the following examples where we simulate Poisson and Gaussian fake data.

```{r, eval=FALSE}
## Function for assessing uniformity of PIT values
pit.plot <- function(mod, name, col){
  stopifnot(class(mod) == 'inla')
  if (name == 'Poisson') {
    pit = mod$cpo$pit-0.5*mod$cpo$cpo
  } else {
    pit = mod$cpo$pit
  }
  hist(pit, breaks = 20, prob = T, col = col,
       main = paste0('PITs histogram for ', name,' model'),
       xlab = 'PIT values')
  test = ks.test(pit, punif)
  print(paste0('Kolmogorov-Smirnov test p-value is ', test$p.value))
}
```

According to PIT checks both plots should show an uniform behavior in
the histogram since the fitting models are exactly the ones where the
data come from. Here we point out that for the Poisson model we have
computed the adjusted PIT values according to the relation

$$
PIT^{\text{adj}}_i = PIT_i - 0.5*CPO_i
$$

since the Poisson data are discrete. Nevertheless, the PIT histogram of
the Poisson model shows a different result compared to the one we
expected. Together with the Kolmogorov-Smirnov test outcome, we can
finalize that this diagnostic cannot be interpreted for the Poisson
case.

### Model implementation

To implement a model, we create an identical copy of it which inherits
initial model's number of elements (n) and its values by using a copy
function.

```{r, eval=FALSE}
m = 100
idx = 1:m
idx.copy = m + 1:m
formula = y ~  f(idx, model="iid2d", n=2*m) +
    f(idx.copy, w, copy="idx") + ....
```

In this notation, the first `m' elements is `a' and the last `m'
elements are `b', and where 'w' are the weights. A copied model may also
have an unknown scaling (hyperparameter), which is default fixed to
be 1. In order to estimate the scaling parameter, it is necessary to
type $\texttt{f(idx.copy, model = "iid", copy = "idx",fixed=FALSE}$.
Small simulated example is provided below:

```{r, eval=FALSE}
n=1000
i=1:n
j = i
z = rnorm(n)

w = runif(n)
y = z  + 2*z*w + rnorm(n)
formula = y ~ f(i, model="iid",initial=0, fixed=T) +
              f(j, w, copy="i", fixed=FALSE)
r = inla(formula, data = data.frame(i,j,w,y))
plot(r)
```

Recall the Base Poisson Model with strength parameters for each Team (Model 1):

```{r}
M1.formula = score ~ -1 + home.adv + f(TeamA,rep(1,n_matches*2),model="iid")+
                      f(TeamB,rep(-1,n_matches*2),copy="TeamA")
```

Here we use copy function for TeamB, because the random effect that we are assigning for football clubs in TeamA are exactly the same ones in TeamB, but appear with different indexing. In order to compute their strength it is necessary that they come from the same model. (omitting copy function will lead to the different functional structure for the model, which we are trying to avoid in this case).
Here `TeamA` is the variable $s_A$, `rep(1, n.matches*2)` is the "the weight in front of $f(TeamA)$".
Options in the $f(sA, ...)$ could be `constr=TRUE`, and `hyper = list(prec = list(initial = -2, fixed=TRUE)))`. For more please check the documentation `?f`.


Another simulated example on time series model (ar1). Here it is necessary to use copy function, because element at time point [i+1] are dependent from the element at time point [i], and all of them come from one model. More detailed explanation here...

```{r, eval=FALSE}
n = 500
phi = 0.8
x = numeric(n)
x[1] = rnorm(1,  sd=sqrt(1/(1-phi^2)))
u = rnorm(n)
for(i in 2:n) {
    x[i] = phi * x[i-1] + u[i]
}
y = matrix(NA, 2*n, 2)
y[1:n, 1] = 0
y[n+1:n, 2] = x

r = inla(y ~ -1
         + f(i, model="iid")
         + f(im, minus, copy = "i",
             hyper = list(beta = list(fixed=FALSE, initial = phi))),
         family = list("gaussian", "gaussian"),
         control.family = list(list(
             hyper = list(prec = list(initial = 0,  fixed=TRUE))),
             list(hyper = list(prec = list(initial = 20,  fixed=TRUE)))),
         data = list(y = y,
                     i=c(1:n, 1:n),
                     im = c(c(NA, 1:(n-1)), rep(NA, n)),
                     minus = c(rep(-1, n), rep(0, n))))
summary(r)
plot(x, pch=19)
lines(x)
lines(r$summary.random$i$mean, lwd=3)

plot(inla.smarginal(r$marginals.hyperpar[[2]]),  type="l",
     main = "marginal for rho,  both verions")

rr = inla(y ~ -1 + f(i, model="ar1"),
         family = "gaussian",
         control.family = list(hyper = list(
                                   prec = list(initial = 20,  fixed=TRUE))),
         data = list(y = x, i=1:n))
summary(rr)
lines(inla.smarginal(rr$marginals.hyperpar[[2]]), lwd=3,  col="red")
```
