---
title: "ELPT"
author: "Henrique Laureano"
format: html
editor: visual
code-line-numbers: true
code-fold: true
code-block-border-left: true
date-modified: 2026/01/13
editor_options: 
  chunk_output_type: console
toc: true
---

```{r pkgs}

if (!requireNamespace("pacman", quietly = TRUE)) 
  install.packages("pacman") 

pacman::p_load(
  ggplot2, googlesheets4, 
  dplyr, lubridate, tidyr, stringr, ggpubr, segmented, broom, pROC, knitr, purrr
)
ggplot2::theme_set(
  theme_classic(base_size = 14) +
    theme(plot.title           = element_text(size = 14, face = "bold"),
          plot.subtitle        = element_text(size = 13, face = "bold"),
          axis.text.x          = element_text(face = "bold"),
          axis.text.y          = element_text(face = "bold"),
          axis.title.x         = element_text(hjust = 0),
          axis.title.y         = element_text(hjust = 0, angle = 360),
          strip.text           = element_text(size = 13, face = "bold"),
          legend.position      = "bottom", 
          legend.justification = "right",
          panel.grid.major     = element_line(color = "gray90", linewidth = 0.7))
)

```

```{r elpt_data, warning=FALSE, message=FALSE}

elpt_url <- 
  paste0(
    "https://docs.google.com/spreadsheets/d/",
    "1FHy8nsW_WfEiWfWXdk7atQlaChNAkJIrAkuNxfOuECg/",
    "edit?gid=1057715313#gid=1057715313"
)
elpt <- googlesheets4::read_sheet(elpt_url) |> dplyr::distinct()

elpt <- elpt |> 
  dplyr::mutate(
    IDADE = lubridate::time_length(
      lubridate::interval(`6 - Data de Nascimento`, 
                          `5 - Data de Cadastro do Exame`), "years"
    )
  )
```

# 1. Análise epidemiológica

## a) Porcentagem de cada faixa etária na amostra

```{r}

elpt |> dplyr::count(`3 - Insira Faixa etária do paciente`) |>
  dplyr::mutate(Percentual = n / nrow(elpt))

```

## b) Setores mais representativos na amostra

```{r}

elpt |> dplyr::count(`2 - Insira o Setor de Solicitação do exame`) |>
  dplyr::mutate(Percentual = n / nrow(elpt)) |>
  dplyr::arrange(dplyr::desc(n)) |> print(n = 22)

```

## c) Sexo

```{r}

elpt |> dplyr::count(`4 - Sexo`) |>
  dplyr::mutate(Percentual = n / nrow(elpt))

```

## d) Presença/ausência de quadros infecciosos e sistema mais afetado em casos positivos para quadros infecciosos

```{r}

elpt |> dplyr::count(`7 - Quadros infecciosos até o momento da coleta?`) |>
  dplyr::mutate(Percentual = n / nrow(elpt))

```

Em quem tem caso positivo para quadro infeccioso

```{r}

elpt |> dplyr::filter(
  `7 - Quadros infecciosos até o momento da coleta?` == "Sim"
) |>
  dplyr::select(`8 - Infecção em sistema nervoso central?`,
                `9 - Infecção de vias áreas superioras?`,
                `10 - Infecção de vias áreas inferiores?`,
                `11 - Infecção de sistema urinário?`,
                `12 - Infecção de sistema gastrointestinal?`,
                `13 - Infecção de pele?`,
                `14 - Sepse?`) |>
  tidyr::pivot_longer(`8 - Infecção em sistema nervoso central?`:`14 - Sepse?`) |>
  dplyr::filter(value == "Sim") |>
  dplyr::count(name) |>
  dplyr::mutate(Percentual = n / sum(n)) |> dplyr::arrange(dplyr::desc(n))

```

Dos 73 pacientes com quadro infeccioso, 22 apresentaram em mais de um sistema (ao menos em dois). 30.14%.

Nestes 22, estes são os sintomas que aparecem e em quantos dos 22 pacientes.

```{r}

proxy <- 
  elpt |> dplyr::filter(
    `7 - Quadros infecciosos até o momento da coleta?` == "Sim"
  ) |>
  dplyr::select(`1 - Insira o Prontuário do Paciente`,
                `8 - Infecção em sistema nervoso central?`,
                `9 - Infecção de vias áreas superioras?`,
                `10 - Infecção de vias áreas inferiores?`,
                `11 - Infecção de sistema urinário?`,
                `12 - Infecção de sistema gastrointestinal?`,
                `13 - Infecção de pele?`,
                `14 - Sepse?`) |>
  tidyr::pivot_longer(!`1 - Insira o Prontuário do Paciente`) |>
  dplyr::filter(value == "Sim") |>
  dplyr::group_by(`1 - Insira o Prontuário do Paciente`) |>
  dplyr::mutate(n = dplyr::n()) |>
  dplyr::ungroup() |>
  dplyr::filter(n > 1) |>
  dplyr::arrange(dplyr::desc(n), `1 - Insira o Prontuário do Paciente`) 

(
  proxy2 <- 
    proxy |>
    dplyr::select(!c(value, n)) |> 
    mutate(name = stringr::str_remove(name, "^[0-9]+ - "),
           name = stringr::str_remove(name, "\\?"),
           name = stringr::str_remove(name, "Infecção (de|em) "),
           name = stringr::str_to_sentence(name)) |>
    dplyr::count(name) |> 
    dplyr::arrange(dplyr::desc(n)) |>
    dplyr::mutate(Percentual = n / 22) 
)

```

O máximo de infecções que um paciente apresenta são 4, e 5 pacientes ficaram em tal situação.

```{r fig.height=7.25}

proxy |>
  dplyr::mutate(value = ifelse(value == "Sim", 1, 0)) |>
  tidyr::pivot_wider(names_from = name, values_from = value, values_fill = 0) |>
  dplyr::select(-n) |> 
  tidyr::pivot_longer(-`1 - Insira o Prontuário do Paciente`, 
                      names_to = "Infection_Type", 
                      values_to = "Present") |>
  mutate(Infection_Type = stringr::str_remove(Infection_Type, "^[0-9]+ - "),
         Infection_Type = stringr::str_remove(Infection_Type, "\\?"),
         Infection_Type = stringr::str_remove(Infection_Type, "Infecção (de|em) "),
         Infection_Type = stringr::str_to_sentence(Infection_Type)) |>
  ggplot() +
  aes(x = factor(Infection_Type, levels = unique(proxy2$name)), 
      y = factor(`1 - Insira o Prontuário do Paciente`, 
                 levels = unique(proxy$`1 - Insira o Prontuário do Paciente`) |> rev()), 
      fill = as.factor(Present)) +
  geom_tile(color = "white") + # Adds a grid line effect
  scale_fill_manual(values = c("0" = "grey95", "1" = "steelblue"),
                    labels = c("Não", "Sim"),
                    name = "Presença: ") +
  labs(x = "Tipo de Infecção", y = "Paciente",
       title = "Mapa de Calor de Infecções por Paciente",
       subtitle = "Apenas pacientes com ao menos dois tipos de infecção") +
  theme(axis.text.x = element_text(angle = 30 , hjust = 1))

```

## e) Porcentagem de indivíduos com comorbidade e comorbidades mais frequentes

```{r}

elpt |> 
  dplyr::count(`21 - Paciente possui alguma comorbidade/diagnostico de base?`) |>
  dplyr::mutate(Percentual = n / nrow(elpt))

elpt |> 
  dplyr::filter(
    `21 - Paciente possui alguma comorbidade/diagnostico de base?` == "Sim"
  ) |>
  dplyr::count(`21.1 -  Qual comorbidade o paciente possui?

-Em caso negativo responder com NA`) |> 
  dplyr::arrange(dplyr::desc(n)) |> dplyr::filter(n > 1)
  
```

Entre os 114 pacientes com comorbidade, 87 diferentes combinações de comorbidade são observadas - mas apenas 12 aparecem em ao menos dois pacientes.

## f) Porcentagem de pacientes que realizam hemodiálise

```{r}

elpt |> 
  dplyr::count(`22 - Paciente realiza hemodiálise?`) |>
  dplyr::mutate(Percentual = n / nrow(elpt))
  
```

## g) Porcentagem de pacientes que passaram por cirurgia nos 30 dias antes do exame

```{r}

elpt |> 
  dplyr::count(
    `23 - Paciente passou por cirurgia nos 30 dias que antecederam a realização do exame ELPT?`
  ) |>
  dplyr::mutate(Percentual = n / nrow(elpt))

```

## h) Porcentagem de pacientes que passaram por tratamento oncológico nos 30 antes do exame

```{r}

elpt |> 
  dplyr::count(
    `24 - Paciente passou por tratamento oncológico nos 30 dias que antecederam a realização do exame ELPT?`
  ) |>
  dplyr::mutate(Percentual = n / nrow(elpt))

```

## i) Porcentagem de pacientes que fizeram uso de medicação

```{r}

elpt |> 
  dplyr::count(
    `27 - Paciente faz uso de medicação que pode causar imunodeficiência nos 30 dias que antecederam a realização do exame ELPT?`
  ) |>
  dplyr::mutate(Percentual = n / nrow(elpt))

```

## j) Porcentagem de pacientes com registro de óbito. Definir intervalo de tempo entre a data do exame e a data do óbito.

```{r}

elpt |> 
  dplyr::count(`33 - Paciente possui registro de óbito?`) |>
  dplyr::mutate(Percentual = n / nrow(elpt))

(
  proxy <- 
    elpt |> 
    dplyr::filter(`33 - Paciente possui registro de óbito?` == "Sim") |>
    dplyr::select(`5 - Data de Cadastro do Exame`, 
                  `33.2 - Data de óbito`) |>
    dplyr::mutate(
      Intervalo_dias = lubridate::time_length(
        lubridate::interval(`5 - Data de Cadastro do Exame`, `33.2 - Data de óbito`), 
        "days"
      ),
      Intervalo_meses = lubridate::time_length(
        lubridate::interval(`5 - Data de Cadastro do Exame`, `33.2 - Data de óbito`), 
        "months"
      )
    )
)

summary(proxy$Intervalo_dias)
summary(proxy$Intervalo_meses)

```

Oito pacientes vieram a óbito (5%), com um tempo médio de sobrevida de 246 dias (8.1 meses) - mediana de 139 dias (4.6 meses).

# 2. Análise de indivíduos com dosagem de IgG

## a) A partir dos valores de dosagem de IgG, verificar se existe correlação com os valores de ELPT; Não considerar na estatistica os pacientes que fazem reposição de IgG - pois é um tratamento, logo não é um dado basal

68 pacientes (41.2%) tem registro do valor de IgG e não fizeram reposição.

```{r}

(
  proxy <- 
    elpt |>
    dplyr::filter(
      `19 - Fez reposições de Imunoglobulinas durante os 30 dias que antecederam a realização do exame ELPT?`
    != "Sim" &
    `18.1 - Como se encontra o resultado de IgG?

NA = não se aplica` != "NA"
    ) |> 
    dplyr::rename(IgG = `18.2 - Qual resultado da dosagem? Colocar apenas número

-Responder com NA em caso de não realização do exame`) |>
    dplyr::rename(ELPT = `16 - Resultado do Primeiro exame`) |>
    dplyr::select(IgG, ELPT) |>
    tidyr::unnest(IgG)  
)

```

Correlação linear de Pearson de 0.55 (forte e estatísticamente significativa, 1.1e-06 = 0.0000011).

Contudo, vemos que o que melhor se adequa aos dados é um comportamento quadrático - subida linear até um igG ao redor de 600 e a partir dali uma queda, mas temos pouquíssimos pacientes passando desse valor.


```{r fig.width=8}

proxy |>
  ggplot() +
  aes(x = IgG, y = ELPT) +
  geom_point(size = 3, shape = 21, fill = "steelblue", alpha = 0.6) +
  geom_smooth(method = "lm", 
              formula = y ~ poly(x, 2), 
              color = "red", 
              se = TRUE) + 
  ggpubr::stat_cor(method = "pearson", label.x = 1000, label.y = 0.575) + 
  labs(title = "Correlação entre IgG e ELPT",
       subtitle = "Modelo Linear Quadrático (y ~ x²) com banda de confiança de 95%",
       x = "IgG (mg/dL)", y = "ELPT (g/dL)") +
  scale_x_continuous(breaks = seq(0, 1400, by = 100)) +
  scale_y_continuous(breaks = seq(0, 1, by = 0.05))

```

## b) Entre os indivíduos com dosagem de IgG abaixo do valor de referência, qual foi o valor médio, mínimo e máximo do valor de ELPT?

```{r}

elpt |>
  dplyr::count(
    `18.1 - Como se encontra o resultado de IgG?

NA = não se aplica`
    ) 

proxy <- 
  elpt |>
    dplyr::filter(
    `18.1 - Como se encontra o resultado de IgG?

NA = não se aplica` == "Abaixo do valor de referência"
    ) |> 
    dplyr::rename(IgG = `18.2 - Qual resultado da dosagem? Colocar apenas número

-Responder com NA em caso de não realização do exame`) |>
    dplyr::rename(ELPT = `16 - Resultado do Primeiro exame`) |>
    dplyr::select(IgG, ELPT) |>
    tidyr::unnest(IgG) 

summary(proxy$ELPT)

proxy |>
  ggplot() +
  aes(x = IgG, y = ELPT) +
  geom_point(size = 3, shape = 21, fill = "steelblue", alpha = 0.6) +
  geom_smooth(method = "lm", 
              formula = y ~ poly(x, 1), 
              color = "red", 
              se = TRUE) + 
  ggpubr::stat_cor(method = "pearson") + 
  labs(title = "Correlação entre IgG e ELPT",
       subtitle = "Modelo Linear (y ~ x) com banda de confiança de 95%",
       x = "IgG (mg/dL)", y = "ELPT (g/dL)") +
  scale_x_continuous(breaks = seq(0, 700, by = 50)) +
  scale_y_continuous(breaks = seq(0, 1, by = 0.05))
  
```

ELPT médio de 0.366, min 0.06 e máx 0.6.

## c)  Entre os indivíduos com dosagem de IgG acima do valor de referência e que NÃO fazem reposição de IgG, qual foi o valor médio, mínimo e máximo do valor de ELPT?

Nenhum paciente com IgG acima do valor de referência.

## d) Entre os indivíduos com dosagem de IgG abaixo do valor de referência, quantos possuíam comorbidade? Quais eram mais frequentes?

22 pacientes.

```{r}

elpt |>
  dplyr::filter(
    `18.1 - Como se encontra o resultado de IgG?

NA = não se aplica` == "Abaixo do valor de referência"
  ) |>
  dplyr::count(`21 - Paciente possui alguma comorbidade/diagnostico de base?`)

elpt |>
  dplyr::filter(
    `18.1 - Como se encontra o resultado de IgG?

NA = não se aplica` == "Abaixo do valor de referência" &
  `21 - Paciente possui alguma comorbidade/diagnostico de base?` == "Sim"
  ) |>
  dplyr::count(`21.1 -  Qual comorbidade o paciente possui?

-Em caso negativo responder com NA`) |>
  dplyr::arrange(dplyr::desc(n))

```

# 3. Análise dos menores de 1 ano

## a) Entre os menores de 1 ano, quantos apresentavam a comorbidade "Prematuridade"?

Apenas um paciente menor de 1 ano. Paciente sem informação de comorbidades.

```{r}

elpt |>
  dplyr::count(`3 - Insira Faixa etária do paciente`)

elpt |>
  dplyr::filter(`3 - Insira Faixa etária do paciente` == "< 1 ano") |>
  dplyr::count(`21 - Paciente possui alguma comorbidade/diagnostico de base?`)

```

## b) Levando em consideração pacientes que fizeram os exames ELPT + IgG, definir um valor de referência para ELPT levando como referência a dosagem de IgG

72 pacientes.

```{r fig.width=8.5}

(
  proxy <- 
    elpt |>
    dplyr::rename(IgG_Referência = `18.1 - Como se encontra o resultado de IgG?

NA = não se aplica`) |>
    dplyr::rename(IgG = `18.2 - Qual resultado da dosagem? Colocar apenas número

-Responder com NA em caso de não realização do exame`) |>
    dplyr::rename(ELPT = `16 - Resultado do Primeiro exame`) |>
    dplyr::filter(IgG_Referência != "NA") |> 
    dplyr::select(IgG, ELPT, IgG_Referência) |>
    tidyr::unnest(IgG)  
)

proxy |> dplyr::count(IgG_Referência)

proxy |>
  ggplot() +
  aes(x = IgG, y = ELPT, fill =IgG_Referência, color = IgG_Referência) +
  geom_point(size = 3, shape = 21, alpha = 0.6) +
  geom_smooth(method = "lm", 
              formula = y ~ poly(x, 1), 
              color = "red", 
              se = TRUE) + 
  ggpubr::stat_cor(method = "pearson", 
                   label.x.npc = 0.6,   # 60% across the x-axis
                   label.y.npc = "bottom") + 
  labs(title = "Correlação entre IgG e ELPT",
       subtitle = "Modelo Linear (y ~ x) com banda de confiança de 95%",
       fill = "Referência: ", color = "Referência: ",
       x = "IgG (mg/dL)", y = "ELPT (g/dL)") +
  scale_x_continuous(breaks = seq(0, 1400, by = 100)) +
  scale_y_continuous(breaks = seq(0, 0.6, by = 0.05))

(
  ref_stats <- proxy |>
    filter(IgG_Referência == "Normal") |>
    summarise(
      mean_elpt = mean(ELPT),
      sd_elpt = sd(ELPT),
      upper_ref = mean_elpt + (2 * sd_elpt),
      lower_ref = mean_elpt - (2 * sd_elpt)
    )
)

```

Valor de referência: 0.47 (95% CI 0.35, 0.58).

```{r fig.width=9, fig.height=6}

lin_mod <- lm(
  ELPT ~ IgG, 
  data = proxy |> dplyr::filter(IgG_Referência != "Acima do valor de referência")
)

# Fit a segmented model (it estimates where the 'plateau' starts)
# You provide an initial guess for the breakpoint (e.g., IgG = 600)
seg_mod <- segmented(lin_mod, seg.Z = ~IgG, psi = 600)

# seg_mod$psi[, "Est."] + c(-1.95, 1.96) * seg_mod$psi[, "St.Err"]

proxy |>
  filter(IgG_Referência != "Acima do valor de referência") |>
  ggplot(aes(x = IgG, y = ELPT)) +
  annotate("rect", xmin = -Inf, xmax = Inf, 
           ymin = ref_stats$lower_ref, ymax = ref_stats$upper_ref, 
           fill = "steelblue", alpha = 0.3) +
  annotate("segment", x = -Inf, xend = Inf, 
           y = ref_stats$mean_elpt, yend = ref_stats$mean_elpt, 
           color = "steelblue", linetype = "dashed", linewidth = 1) +
  geom_point(aes(fill = IgG_Referência), shape = 21, size = 3, alpha = 0.8) +
  geom_smooth(
    aes(color = IgG_Referência), 
    method = "lm", formula = y ~ poly(x, 1), se = TRUE, linewidth = 1
  ) +
  geom_vline(xintercept = seg_mod$psi[, "Est."], linetype = "dashed", alpha = 0.7) +
  scale_fill_manual(
    values = c("Normal" = "white", "Abaixo do valor de referência" = "orange"),
    labels = c("Abaixo da Referência", "Normal")
  ) +
  scale_color_manual(
    values = c("Normal" = "darkblue", "Abaixo do valor de referência" = "darkorange"),
    labels = c("Abaixo da Referência", "Normal")
  ) +
  labs(
    title = "Baseline de ELPT Baseado no Platô de IgG (Grupo Normal)",
    subtitle = "Linhas de tendência com Intervalo de Confiança de 95% (sombreado)",
    x = "IgG (mg/dL)", 
    y = "ELPT (g/dL)",
    fill = "Classificação IgG: ", color = "Classificação IgG: "
  ) +
  scale_x_continuous(breaks = seq(0, 1500, by = 100)) +
  scale_y_continuous(breaks = seq(0, 0.6, by = 0.05))

```

Além disso, estimamos um ponto de corte para ver onde se inicia o platô - onde termina o padrão de crescimento e se inicia a estagnação de ELPT médio em relação ao IgG, é em 588.

```{r}

summary(seg_mod)

```

Aqui é apenas para "comprovar" que o grupo "Normal" não tem inclinação estatísticamente significativa. Neste grupo, independente do valor de IgG se espera o mesmo valor de ELPT.

```{r}

proxy |>
  dplyr::filter(IgG_Referência != "Acima do valor de referência") |>
  dplyr::group_by(IgG_Referência) |>
  dplyr::group_modify(~ broom::tidy(lm(ELPT ~ IgG, data = .x), conf.int = TRUE)) |>
  dplyr::filter(term == "IgG") |>
  dplyr::select(IgG_Referência, estimate, std.error, p.value, conf.low, conf.high)

```

## Explicação mais detalhada

### 1. Establishment of the Baseline Reference

To define a physiological ELPT baseline, the Normal Group (patients with IgG within the reference range) was used as the normative standard.

* **Process:** We calculated the mean and standard deviation (SD) for the Normal group. The shaded area in the visualization represents the Mean ± 2 SD, covering approximately 95% of the expected physiological variation.

* **Interpretation:** ELPT values falling below this band indicate a pathological deficit relative to the established biological baseline.

### 2. Group Dynamics: The "Rise vs. Attenuation" Effect

The relationship was modeled separately for each group to identify how IgG deficiency impacts ELPT measurements.

* **Below Reference Group:** This group exhibits a significant positive slope ($p < 0.05$). This demonstrates that in patients with low IgG, ELPT is "coupled" to IgG levels—as IgG increases, ELPT rises proportionally toward the baseline.

* **Normal Group:** This group shows a significant change in trajectory. While the steep recovery phase ends, the group exhibits an attenuation of the slope ($p > 0.05$ for a flat plateau or a very weak negative trend), representing the transition to a physiological steady state.

### 3. Segmented Regression (Inflection Point)

A Segmented (Broken-stick) Regression was applied to mathematically determine the threshold of stabilization.

* **The Breakpoint:** The model identifies the specific IgG coordinate where the linear recovery phase ends and the stabilization phase begins. 

* **Clinical Utility:** This point defines the "Critical IgG Threshold" required for an ELPT measurement to be considered stable and diagnostically reliable, independent of hypogammaglobulinemia interference.

---

### Summary of Statistical Findings

A positive linear dependency was observed between ELPT and IgG strictly within the deficient group ($p < 0.05$). Conversely, the normal group exhibited a stabilization phase, establishing a stable reference baseline for clinical interpretation¹.

¹ *Note: While the second segment in the ELPT model shows a statistically significant negative trend (p < 0.05), the effect size is minimal compared to the recovery phase, indicating a gradual attenuation rather than a flat plateau.*

# How to use ELPT to predict IgG deficiency

> Minimizing false positives, prioritizing Specificity and Positive Predictive Value (PPV).
>
> - Catch fewer sick people (lower sensitivity), but almost everyone catched will actually be sick.

```{r}

# 1. Prepare Data
proxy_roc <- proxy |>
  filter(IgG_Referência != "Acima do valor de referência") |>
  mutate(low_igg_flag = ifelse(IgG_Referência == "Abaixo do valor de referência", 1, 0))

# 2. Generate ROC Object
roc_obj <- roc(proxy_roc$low_igg_flag, proxy_roc$ELPT, quiet = TRUE)

# 3. Extract Scenarios

# A. Max Specificity (The "Perfect" but useless one)
scen_max_spec <- coords(roc_obj, "all", ret = c("threshold", "specificity", "sensitivity", "ppv")) |>
  filter(specificity == 1) |>
  slice(1) |>
  mutate(Strategy = "Max Specificity (100%)")

# B. High Specificity (The >90% attempt)
scen_high_spec <- coords(roc_obj, "all", ret = c("threshold", "specificity", "sensitivity", "ppv")) |>
  filter(specificity >= 0.90) |>
  arrange(desc(sensitivity)) |> # Get best sensitivity in this range
  slice(1) |>
  mutate(Strategy = "High Specificity (>90%)")

# C. Balanced (Youden's Index - The Winner)
scen_balanced <- coords(roc_obj, "best", best.method = "youden", 
                        ret = c("threshold", "specificity", "sensitivity", "ppv")) |>
  mutate(Strategy = "Balanced (Youden's Index)")

# 4. Combine into a Summary Table
roc_summary <- bind_rows(scen_max_spec, scen_high_spec, scen_balanced) |>
  dplyr::select(
    Strategy, 
    Threshold = threshold, 
    Sensitivity = sensitivity, Specificity = specificity, PPV = ppv
  )

# Display Table
kable(roc_summary, digits = 3, caption = "Comparison of Cutoff Strategies")

# 5. Visualization: Density Plot with the Winner Cutoff
optimal_cutoff <- scen_balanced$threshold

proxy |>
  filter(IgG_Referência != "Acima do valor de referência") |>
  ggplot(aes(x = ELPT, fill = IgG_Referência)) +
  geom_density(alpha = 0.4) +
  geom_vline(xintercept = optimal_cutoff, linetype = "dashed", color = "black", linewidth = 1) +
  annotate("text", x = optimal_cutoff, y = 0, label = paste(" Optimal Cutoff:", round(optimal_cutoff, 2)), 
           hjust = 1.05, vjust = -2, angle = 0, fontface = "bold") +
  scale_fill_manual(values = c("Normal" = "steelblue", "Abaixo do valor de referência" = "orange")) +
  labs(
    title = "Clinical Decision Threshold",
    subtitle = "Overlap of ELPT distributions with optimal screening cutoff",
    x = "ELPT (g/dL)", y = "Density", fill = "IgG Status"
  ) +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1))

```

## Diagnostic Screening: ELPT as a Predictor for IgG Testing

We evaluated the diagnostic performance of **ELPT** to identify a threshold that signals IgG deficiency.

We compared three cutoff strategies to determine the optimal balance between minimizing false positives (Specificity) and maximizing disease detection (Sensitivity).

### Analysis of Cutoff Strategies

The table above summarizes the performance of the potential thresholds:

1.  **Max Specificity Strategy (Cutoff 0.250):**
    * **Pros:** Perfect Specificity (100%) and PPV (100%). If a patient falls below this level, they are certainly deficient.
    * **Cons:** Sensitivity is critically low (25%). This threshold is too conservative for screening, as it misses nearly three-quarters of the target population.

2.  **High Specificity Strategy (Cutoff 0.395):**
    * **Performance:** This threshold provides strong specificity (91%) with a Positive Predictive Value of 81%.
    * **Trade-off:** Sensitivity increases to 60.7%, capturing a majority of cases while maintaining a low false-positive rate.

3.  **Balanced "Youden" Strategy (Cutoff 0.410):**
    * **Pros:** Optimizes the overall accuracy. It offers the highest **Sensitivity (64.3%)** among the viable options while maintaining a robust **Specificity (88.6%)**.
    * **Clinical Context:** Unlike PROTF, which prioritized sensitivity at the cost of specificity, ELPT demonstrates naturally higher specificity. The values for the "High Specificity" and "Balanced" strategies are numerically very close (0.395 vs. 0.410), indicating a stable diagnostic zone.

### Conclusion and Recommendation

We recommend the **Balanced Strategy** as the clinical standard for ELPT.

**Recommendation:** An ELPT value below **0.410** should trigger a follow-up IgG test.

* **Performance:** At this threshold, the test detects approximately **65%** of IgG-deficient patients (Sensitivity).
* **Precision:** Crucially, it generates very few false alarms (Specificity **88.6%**), meaning that patients flagged by ELPT have a high probability (PPV **78.3%**) of actually requiring intervention.

## Advanced Strategy: The "Indeterminate Zone" Approach

```{r}

# 1. Prepare Data & ROC
proxy_roc <- proxy |>
  filter(IgG_Referência != "Acima do valor de referência") |>
  mutate(low_igg_flag = ifelse(IgG_Referência == "Abaixo do valor de referência", 1, 0))

roc_obj <- roc(proxy_roc$low_igg_flag, proxy_roc$ELPT, quiet = TRUE)

# 2. Extract All Coordinates
all_coords <- coords(roc_obj, "all", ret = c("threshold", "specificity", "sensitivity"))

# 3. Find the Boundaries (Using >= Logic to avoid NA)

# A. LOWER CUTOFF (Red Zone Boundary)
# Logic: We want High Specificity (>= 95%) to be sure they are sick.
# We pick the threshold with the highest sensitivity possible within that constraint.
cutoff_red <- all_coords |>
  filter(specificity >= 0.95) |>
  arrange(desc(sensitivity)) |> 
  slice(1) |>
  pull(threshold)

# B. UPPER CUTOFF (Green Zone Boundary)
# Logic: We want High Sensitivity (>= 95%) to be sure we don't miss anyone.
# We pick the threshold with the highest specificity possible within that constraint.
cutoff_green <- all_coords |>
  filter(sensitivity >= 0.95) |>
  arrange(desc(specificity)) |> 
  slice(2) |>
  pull(threshold)

# 4. Print Values for verification
rbind(
  paste("Red Zone (Deficient) <", round(cutoff_red, 2)),
  paste("Grey Zone (Indeterminate):", round(cutoff_red, 2), "-", round(cutoff_green, 2)),
  paste("Green Zone (Safe) >", round(cutoff_green, 2))
)

```

```{r fig.width=9.5, fig.height=6}

# 2. Visualize the Zones
proxy |>
  filter(IgG_Referência != "Acima do valor de referência") |>
  ggplot(aes(x = ELPT, fill = IgG_Referência)) +
  geom_density(alpha = 0.4) +
  # Red Zone
  annotate("rect", xmin = -Inf, xmax = cutoff_red, ymin = 0, ymax = Inf, 
           fill = "firebrick", alpha = 0.1) +
  # Grey Zone
  annotate("rect", xmin = cutoff_red, xmax = cutoff_green, ymin = 0, ymax = Inf, 
           fill = "gold", alpha = 0.15) +
  # Green Zone
  annotate("rect", xmin = cutoff_green, xmax = Inf, ymin = 0, ymax = Inf, 
           fill = "forestgreen", alpha = 0.1) +
  geom_vline(xintercept = c(cutoff_red, cutoff_green), linetype = "dashed") +
  annotate("text", x = cutoff_red, y = 0, label = paste("Red <", round(cutoff_red, 2)), 
           hjust = 1.1, vjust = -10, angle = 0, color = "firebrick") +
  annotate("text", x = cutoff_green, y = 0, label = paste("Green >", round(cutoff_green, 2)), 
           hjust = 1.1, vjust = -10, angle = 0, color = "forestgreen") +
  scale_fill_manual(values = c("Normal" = "steelblue", "Abaixo do valor de referência" = "orange")) +
  labs(title = "Traffic Light System: Managing Clinical Overlap",
       subtitle = "Red: High Probability of Deficiency | Grey: Indeterminate | Green: High Probability of Normal",
       x = "ELPT (g/dL)", y = "Density", fill = "IgG Status") +
  scale_x_continuous(breaks = seq(0, 1, by = 0.1)) +
  scale_y_continuous(breaks = seq(0, 10, by = 1))

```

Given the distributional overlap observed in the ELPT data, a single binary cutoff may not sufficiently capture the clinical complexity. To address this, we applied a **Two-Cutoff Strategy** (Traffic Light System) to isolate the zone of diagnostic uncertainty.

We defined three clinical zones based on strict statistical safety margins:

1.  **Deficiency Zone (< 0.38):**
    * **Definition:** Threshold established at **≥95% Specificity**.
    * **Implication:** ELPT values below **0.38** are highly indicative of IgG deficiency. The probability of a false positive in this range is minimal, warranting immediate clinical action or substitution therapy consideration.

2.  **Safety Zone (> 0.60):**
    * **Definition:** Threshold established at **≥95% Sensitivity**.
    * **Implication:** ELPT values above **0.60** effectively rule out deficiency with high confidence. The risk of missing a true deficient case in this range is negligible.

3.  **Indeterminate "Grey" Zone (0.38 – 0.60):**
    * **Definition:** The interval between the high-specificity and high-sensitivity thresholds.
    * **Implication:** Patients falling within this range (0.38 to 0.60) represent a diagnostic challenge where ELPT alone is inconclusive due to biological overlap. For these individuals, **mandatory IgG quantification** is recommended to resolve the diagnosis.

**Conclusion:** By defining 0.38 and 0.60 as the critical boundaries, we enhance diagnostic precision for patients at the extremes while clearly identifying the subset of patients requiring confirmatory testing.

## Infections

```{r}

# Define your Cutoff (Use the Balanced one found earlier)
elpt_cutoff <- 0.41

infection_analysis <- elpt |>
  dplyr::rename(ELPT = `16 - Resultado do Primeiro exame`) |>
  # Create Binary Groups based on Cutoff
  mutate(Risk_Group = ifelse(ELPT < elpt_cutoff, "High_Risk", "Low_Risk")) |>
  dplyr::select(
    Risk_Group,
    `8 - Infecção em sistema nervoso central?`,
    `9 - Infecção de vias áreas superioras?`,
    `10 - Infecção de vias áreas inferiores?`,
    `11 - Infecção de sistema urinário?`,
    `12 - Infecção de sistema gastrointestinal?`,
    `13 - Infecção de pele?`,
    `14 - Sepse?`
  ) |>
  pivot_longer(
    cols = !Risk_Group,
    names_to = "Infection_Type",
    values_to = "Status"
  ) |>
  mutate(
    Infection_Type = stringr::str_remove(Infection_Type, "^\\d+ - "),
    Infection_Type = stringr::str_remove(Infection_Type, "\\?"),
    Infection_Type = stringr::str_remove(Infection_Type, "^Infecção (de|em) "),
    Infection_Type = stringr::str_to_sentence(Infection_Type),
    Is_Infected = ifelse(Status == "Sim", 1, 0)
  ) |>
  # Remove NAs if any exist in Status/Risk_Group
  filter(!is.na(Is_Infected))

rates_table <- infection_analysis |>
  group_by(Infection_Type, Risk_Group) |>
  summarise(
    Total_Patients = n(),
    Infected_Count = sum(Is_Infected),
    Rate_Pct = (Infected_Count / Total_Patients) * 100, # Em porcentagem
    .groups = "drop"
  ) |>
  # Coloca High_Risk e Low_Risk lado a lado
  pivot_wider(
    names_from = Risk_Group,
    values_from = c(Total_Patients, Infected_Count, Rate_Pct)
  )

stats_table <- infection_analysis |>
  group_by(Infection_Type) |>
  nest() |>
  mutate(
    model = map(data, function(df) {
      # Tabela cruzada 2x2
      tbl <- table(df$Risk_Group, df$Is_Infected)
      
      # Verifica se a tabela é válida (tem 2 grupos de risco e pelo menos infectados e não infectados no geral)
      # Se for muito esparsa, fisher.test pode falhar ou retornar NULL
      tryCatch({
        broom::tidy(fisher.test(tbl))
      }, error = function(e) NULL)
    })
  ) |>
  unnest(model) |>
  dplyr::select(Infection_Type, estimate, p.value, conf.low, conf.high)

final_results <- rates_table |>
  left_join(stats_table, by = "Infection_Type") |>
  mutate(
    Odds_Ratio = estimate,
    Significant = ifelse(p.value < 0.05, "Yes", "No")
  ) |>
  dplyr::select(
    Infection_Type, 
    Rate_High = Rate_Pct_High_Risk, 
    Rate_Low = Rate_Pct_Low_Risk,
    Odds_Ratio, 
    conf.low, 
    conf.high,
    p.value, 
    Significant
  )

knitr::kable(
  final_results, digits = 2, 
  caption = "Prevalência de Infecções por Grupo de Risco (ELPT < 0.41)"
)

```

Odds Ratio: Normal (>= 0.41) vs. Low (< 0.41). 0.43 means que o grupo normal tem menos chances.

```{r fig.width=8, fig.height=4}

final_results |>
  filter(!is.na(Odds_Ratio)) |> 
  ggplot(aes(x = Odds_Ratio, y = reorder(Infection_Type, Odds_Ratio), color = Significant)) +
  geom_point(size = 3.5) +
  geom_errorbar(aes(xmin = conf.low, xmax = conf.high), width = 0.3, linewidth = 0.8) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray40", linewidth = 1) +
  scale_x_log10() + 
  scale_color_manual(values = c("Yes" = "#D55E00", "No" = "gray60")) +
  labs(
    title = "Clinical Impact of Low ELPT (< 0.41 g/dL)",
    subtitle = "Odds Ratio of Infection Risk (High Risk vs. Low Risk Group)",
    x = "Odds Ratio (Log Scale) \n >1 indicates higher risk in Low ELPT group",
    y = NULL,
    color = "Significant (p < 0.05)?"
  )

```

### Clinical Validation: Association with Infection History (ELPT)

To determine if the ELPT cutoff (**0.410**) translates into a functional clinical marker, we assessed whether patients falling below this threshold exhibited a higher prevalence of infections compared to those above it.

* **Methodology:** Patients were stratified into "High Risk" (ELPT < 0.410) and "Low Risk" (ELPT ≥ 0.410) cohorts. We calculated the Prevalence Rate (%) and Odds Ratio (OR) for seven specific infection types using Fisher's Exact Test.

* **Results:**
    * **Absence of Phenotypic Correlation:** Unlike the PROTF marker, the ELPT cutoff did not demonstrate a statistically significant association with any specific infection type. P-values for all categories exceeded the significance threshold ($p > 0.05$).
    * **Uniform Infection Rates:** Infection rates were remarkably similar between the high-risk and low-risk groups across most categories. For example, **Sepsis** prevalence was nearly identical (18.18% in the Low ELPT group vs. 19.61% in the Normal ELPT group, $p = 1.00$).
    * **Urinary Tract Trend:** A non-significant trend was observed for **Urinary System Infections**, which were more frequent in the "High Risk" group (27.27%) compared to the "Low Risk" group (13.73%). However, this difference did not reach statistical significance ($p = 0.19$).

**Conclusion:** While the ELPT cutoff of 0.410 is statistically valid for screening IgG deficiency (as shown in the ROC analysis), it does not appear to independently stratify patients by specific infectious history in this dataset. This suggests that ELPT should be utilized primarily as a biochemical screening tool for IgG levels rather than a direct predictor of clinical infection phenotypes.

# Methodology & References

All analyses were conducted using the `R` language and environment for statistical computing (R Core Team, 2025). Data manipulation and string processing were performed using `dplyr` (Wickham et al., 2023), `tidyr` (Wickham et al., 2024), and `stringr` (Wickham, 2023). Temporal data were handled with `lubridate` (Grolemund & Wickham, 2011).

To date, the study has focused on data cleaning, feature engineering, and advanced visualization using `ggplot2` (Wickham, 2016). A key objective was the identification of biological cutoff points for ELPT where existing references were unknown or required validation. To achieve this, we utilized a two-step modeling approach:

1. **Reference Interval Modeling:** We established biological baselines by calculating the mean and standard deviation (± 2 SD) of the "Normal" IgG cohort, treating this group as a stable physiological standard.
2. **Threshold Discovery via Segmented Regression:** To identify the specific IgG level at which ELPT stabilizes, we implemented segmented (broken-stick) regression (Muggeo, 2008). This allowed us to mathematically determine the "inflection point" between the rising deficient phase and the steady-state phase.

Statistical significance of the observed slopes and the fit of the resulting models were verified using tidied coefficients extracted via `broom` (Robinson et al., 2024).

<!-- In the next steps, we plan to expand these associations using generalized linear models (GLMs - McCullagh & Nelder, 1989) and generalized additive models (GAMs - Hastie & Tibshirani, 1990; Wood, 2017) to account for potential non-linear effects across the broader dataset. -->

## References

> R Core Team (2025). *R: A Language and Environment for Statistical Computing*. R Foundation for Statistical Computing, Vienna, Austria. <https://www.R-project.org/>.
>
> Wickham, H. (2016). *ggplot2: Elegant Graphics for Data Analysis*. Springer-Verlag New York.
>
> Wickham, H., François, R., Henry, L., Müller, K., & Vaughan, D. (2023). *dplyr: A Grammar of Data Manipulation*. R package version 1.1.4.
>
> Wickham, H., Vaughan, D., & Girlich, M. (2024). *tidyr: Tidy Messy Data*. R package version 1.3.1.
>
> Wickham, H. (2023). *stringr: Simple, Consistent Wrappers for Common String Operations*. R package version 1.5.1.
>
> Robinson, D., Hayes, A., & Couch, S. (2024). *broom: Glance, Tidy, and Augment Regression Models*. R package version 1.0.6.
> 
> Muggeo, V. M. R. (2008). *segmented: an R Package to Fit Regression Models with Broken-Line Relationships*. R News, 8/1, 20-25.
>
> Garrett Grolemund, Hadley Wickham (2011). *Dates and Times Made Easy with lubridate*. Journal of Statistical Software, 40(3), 1-25.
<!-- > -->
<!-- > McCullagh, P., & Nelder, J. A. (1989). *Generalized Linear Models* (2nd ed.). Chapman & Hall. -->
<!-- > -->
<!-- > Hastie, T., & Tibshirani, R. (1990). *Generalized Additive Models*. Chapman & Hall. -->
<!-- > -->
<!-- > Wood, S. N. (2017). *Generalized Additive Models: An Introduction with R* (2nd ed.). CRC Press. -->